<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'><rect fill='%233b82f6' width='32' height='32' rx='4'/></svg>" type="image/svg+xml">
    <title>Qwen3-ASR 高级客户端</title>
    <style>
        *, *::before, *::after { box-sizing: border-box; }
        :root {
            --primary-50: #eff6ff;
            --primary-100: #dbeafe;
            --primary-200: #bfdbfe;
            --primary-300: #93c5fd;
            --primary-400: #60a5fa;
            --primary-500: #3b82f6;
            --primary-600: #2563eb;
            --primary-700: #1d4ed8;
            --primary-800: #1e40af;
            --primary-900: #1e3a8a;
            --neutral-50: #f8fafc;
            --neutral-100: #f1f5f9;
            --neutral-200: #e2e8f0;
            --neutral-300: #cbd5e1;
            --neutral-400: #94a3b8;
            --neutral-500: #64748b;
            --neutral-600: #475569;
            --neutral-700: #334155;
            --neutral-800: #1e293b;
            --neutral-900: #0f172a;
        }
        
        html { overflow-x: hidden; }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 12px;
            min-height: 100vh;
            background-color: var(--neutral-100);
            color: var(--neutral-800);
            overflow-x: hidden;
        }
        
        .container {
            width: 100%;
            max-width: 1100px;
            margin: 0 auto;
            background: white;
            border-radius: 10px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.08), 0 4px 12px rgba(0, 0, 0, 0.06);
            overflow: hidden;
        }
        
        .header {
            background: linear-gradient(90deg, var(--primary-600), var(--primary-700));
            color: white;
            padding: 16px 20px;
            text-align: center;
        }
        
        .header h1 {
            margin: 0;
            font-size: 1.5rem;
        }
        
        .header p {
            margin: 8px 0 0 0;
            opacity: 0.9;
            font-size: 0.9rem;
        }
        
        .tabs {
            display: flex;
            border-bottom: 1px solid var(--neutral-200);
            background: var(--neutral-50);
            overflow-x: hidden;
        }
        
        .tab-button {
            padding: 12px 16px;
            border: none;
            background: transparent;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            color: var(--neutral-600);
            border-bottom: 2px solid transparent;
            transition: all 0.2s ease;
            white-space: nowrap;
            flex: 1 1 0;
            min-width: 0;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .tab-button.active {
            color: var(--primary-600);
            border-bottom-color: var(--primary-600);
            background: white;
        }
        
        .tab-content {
            display: none;
            padding: 16px;
            overflow-x: hidden;
            min-width: 0;
        }
        
        .tab-content.active {
            display: block;
        }
        
        .row {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin-bottom: 20px;
            min-width: 0;
        }
        
        .column {
            flex: 1 1 280px;
            min-width: 0;
            max-width: 100%;
        }
        
        .form-group {
            margin-bottom: 15px;
        }
        
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
            color: var(--neutral-700);
        }
        
        select, button {
            width: 100%;
            padding: 10px;
            border: 1px solid var(--neutral-300);
            border-radius: 4px;
            font-size: 14px;
        }
        
        button {
            background: var(--primary-600);
            color: white;
            border: none;
            cursor: pointer;
            font-weight: 500;
            transition: background 0.2s ease;
        }
        
        button:hover {
            background: var(--primary-700);
        }
        
        button:disabled {
            background: var(--neutral-400);
            cursor: not-allowed;
        }
        
        .btn-row {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }
        
        .btn-row button {
            flex: 1 1 120px;
            min-width: 0;
        }
        
        textarea {
            width: 100%;
            min-height: 160px;
            height: 200px;
            padding: 12px;
            border: 1px solid var(--neutral-300);
            border-radius: 6px;
            font-family: inherit;
            font-size: 14px;
            resize: vertical;
        }
        
        .status-bar {
            padding: 10px 15px;
            background: var(--neutral-100);
            border-radius: 4px;
            margin-top: 15px;
            font-size: 14px;
            color: var(--neutral-600);
        }
        
        .recording-actions {
            margin-top: 16px;
        }
        .recording-actions .btn-row {
            margin-bottom: 8px;
        }
        .audio-player-inner {
            margin-top: 8px;
        }
        .audio-player-inner audio {
            width: 100%;
            max-width: 100%;
        }
        
        .recording-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            background-color: #ef4444;
            border-radius: 50%;
            margin-right: 8px;
            animation: pulse 1.5s infinite;
        }
        
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.4; }
            100% { opacity: 1; }
        }
        
        .visualizer-wrap {
            margin: 10px 0;
        }
        .visualizer-level {
            font-size: 13px;
            color: var(--neutral-600);
            margin-bottom: 4px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .visualizer-level-num {
            font-weight: 700;
            font-size: 18px;
            color: var(--primary-600);
            min-width: 3em;
        }
        .visualizer-level-peak {
            font-weight: 600;
            font-size: 14px;
            color: var(--neutral-600);
            min-width: 4em;
        }
        .visualizer-level-bar-bg {
            flex: 1;
            height: 12px;
            background: var(--neutral-200);
            border-radius: 6px;
            overflow: hidden;
        }
        .visualizer-level-bar-fill {
            height: 100%;
            border-radius: 6px;
            background: linear-gradient(90deg, var(--primary-400), var(--primary-600));
            width: 0%;
            transition: width 0.05s ease-out;
        }
        .visualizer {
            height: 100px;
            min-height: 100px;
            background: var(--neutral-100);
            border-radius: 6px;
            position: relative;
            overflow: hidden;
        }
        
        .visualizer-bar {
            position: absolute;
            bottom: 0;
            min-width: 3px;
            background: var(--primary-500);
            border-radius: 3px 3px 0 0;
        }

        /* 设备选择行：小屏时下拉与测试按钮可换行 */
        .device-row {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            align-items: center;
        }
        .device-row select {
            flex: 1 1 180px;
            min-width: 0;
        }
        .device-row .test-btn {
            flex: 0 0 auto;
        }

        /* 自适应：手机竖屏 */
        @media (max-width: 640px) {
            body { padding: 8px; }
            .header { padding: 14px 12px; }
            .header h1 { font-size: 1.25rem; }
            .header p { font-size: 0.85rem; }
            .tab-content { padding: 12px; }
            .row { gap: 16px; margin-bottom: 16px; }
            .column { flex-basis: 100%; }
            .btn-row button { flex-basis: 100%; }
            textarea { min-height: 140px; height: 180px; }
            .visualizer { height: 80px; min-height: 80px; }
        }

        /* 自适应：平板 / 小桌面 */
        @media (min-width: 641px) and (max-width: 900px) {
            .column { flex-basis: 100%; }
        }

        /* 自适应：宽屏 */
        @media (min-width: 1200px) {
            body { padding: 24px; }
            .container { max-width: 1200px; }
            .header { padding: 24px; }
            .header h1 { font-size: 1.8rem; }
            .tab-content { padding: 24px; }
        }

    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Qwen3-ASR 高级语音识别</h1>
            <p>支持上传音频文件或使用麦克风进行实时语音识别</p>
        </div>
        
        <div class="tabs">
            <button class="tab-button active" data-tab="upload">上传音频</button>
            <button class="tab-button" data-tab="microphone">麦克风录音</button>
        </div>
        
        <div class="tab-content active" id="upload-tab">
            <div class="row">
                <div class="column">
                    <div class="form-group">
                        <label for="audio-upload">上传音频文件</label>
                        <input type="file" id="audio-upload" accept="audio/*" style="display: none;">
                        <button type="button" onclick="document.getElementById('audio-upload').click()">选择音频文件</button>
                        <div id="file-name" style="margin-top: 5px; font-size: 12px; color: var(--neutral-500);"></div>
                    </div>
                    
                    <div class="form-group">
                        <label for="upload-language">指定语言（设为None则自动检测）</label>
                        <select id="upload-language">
                            <option value="auto">自动检测</option>
                            <option value="zh">中文</option>
                            <option value="en">英文</option>
                            <option value="yue">粤语</option>
                            <option value="ja">日语</option>
                            <option value="ko">韩语</option>
                            <option value="de">德语</option>
                            <option value="fr">法语</option>
                            <option value="es">西班牙语</option>
                        </select>
                    </div>
                    
                    <button id="upload-btn">转录音频</button>
                </div>
                
                <div class="column">
                    <label>转录结果</label>
                    <textarea id="upload-result" readonly placeholder="转录结果将显示在这里..."></textarea>
                    <div class="status-bar" id="upload-status">就绪</div>
                </div>
            </div>
        </div>
        
        <div class="tab-content" id="microphone-tab">
            <div class="row">
                <div class="column">
                    <div class="form-group">
                        <label for="mic-device">选择麦克风设备</label>
                        <div class="device-row">
                            <select id="mic-device">
                                <option value="">使用系统默认</option>
                            </select>
                            <button type="button" id="test-device-btn" class="test-btn" title="试听当前设备，看电平条是否随说话动">测试此设备</button>
                        </div>
                        <div id="mic-device-hint" style="margin-top: 4px; font-size: 12px; color: var(--neutral-500); min-height: 16px;"></div>
                        <div id="mic-test-status" style="margin-top: 4px; font-size: 12px; color: var(--primary-600); min-height: 16px;"></div>
                    </div>
                    
                    <div class="form-group">
                        <label for="mic-language">指定语言（设为None则自动检测）</label>
                        <select id="mic-language">
                            <option value="auto">自动检测</option>
                            <option value="zh">中文</option>
                            <option value="en">英文</option>
                            <option value="yue">粤语</option>
                            <option value="ja">日语</option>
                            <option value="ko">韩语</option>
                            <option value="de">德语</option>
                            <option value="fr">法语</option>
                            <option value="es">西班牙语</option>
                        </select>
                    </div>
                    
                    <div class="btn-row">
                        <button id="start-rec-btn">开始录音</button>
                        <button id="stop-rec-btn" disabled>停止录音</button>
                    </div>
                    
                    <div class="form-group" style="margin-top: 15px;">
                        <div id="rec-status">就绪</div>
                        <div class="visualizer-wrap">
                            <div class="visualizer-level" id="visualizer-level-wrap" style="display: none;">
                                <span class="visualizer-level-num" id="visualizer-level-num">0%</span>
                                <span>当前</span>
                                <div class="visualizer-level-bar-bg">
                                    <div class="visualizer-level-bar-fill" id="visualizer-level-bar"></div>
                                </div>
                                <span class="visualizer-level-peak" id="visualizer-level-peak">峰值 0%</span>
                            </div>
                            <div class="visualizer" id="audio-visualizer"></div>
                        </div>
                    </div>
                    
                    <div class="form-group recording-actions">
                        <label>录音回放</label>
                        <div class="btn-row">
                            <button id="play-btn" disabled>播放录音</button>
                            <button id="download-btn" disabled title="录音结束后可下载">下载录音</button>
                        </div>
                        <div class="audio-player-inner" id="audio-player-container" style="display: none;">
                            <audio id="audio-player" controls></audio>
                        </div>
                    </div>
                </div>
                
                <div class="column">
                    <label>转录结果</label>
                    <textarea id="mic-result" readonly placeholder="转录结果将显示在这里..."></textarea>
                    <div class="status-bar" id="mic-status">就绪</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // API 地址：若你的服务映射到其它端口，改这里（与 WSL Docker -p 一致）
        const API_BASE = 'http://localhost:8000';

        // 全局变量
        let mediaRecorder;
        let audioChunks = [];
        let recordedAudioBlob;
        let audioContext;
        let analyser;
        let animationId;
        let pcmChunks = [];
        let recordingStartTime = 0;
        let previousAudioDevices = [];
        let deviceChangeDebounceTimer = null;

        function encodePCMToWav(pcmChunks, sampleRate) {
            let totalLen = 0;
            for (let i = 0; i < pcmChunks.length; i++) totalLen += pcmChunks[i].length;
            const pcm = new Float32Array(totalLen);
            let offset = 0;
            for (let i = 0; i < pcmChunks.length; i++) {
                pcm.set(pcmChunks[i], offset);
                offset += pcmChunks[i].length;
            }
            const numChannels = 1;
            const bitsPerSample = 16;
            const byteRate = sampleRate * numChannels * (bitsPerSample / 8);
            const dataSize = pcm.length * (bitsPerSample / 8);
            const buffer = new ArrayBuffer(44 + dataSize);
            const view = new DataView(buffer);
            const writeStr = (offset, str) => { for (let i = 0; i < str.length; i++) view.setUint8(offset + i, str.charCodeAt(i)); };
            writeStr(0, 'RIFF');
            view.setUint32(4, 36 + dataSize, true);
            writeStr(8, 'WAVE');
            writeStr(12, 'fmt ');
            view.setUint32(16, 16, true);
            view.setUint16(20, 1, true);
            view.setUint16(22, numChannels, true);
            view.setUint32(24, sampleRate, true);
            view.setUint32(28, byteRate, true);
            view.setUint16(32, numChannels * (bitsPerSample / 8), true);
            view.setUint16(34, bitsPerSample, true);
            writeStr(36, 'data');
            view.setUint32(40, dataSize, true);
            for (let i = 0; i < pcm.length; i++) {
                const s = Math.max(-1, Math.min(1, pcm[i]));
                view.setInt16(44 + i * 2, s < 0 ? s * 0x8000 : s * 0x7FFF, true);
            }
            return new Blob([buffer], { type: 'audio/wav' });
        }

        // 检查是否在安全上下文中（HTTPS 或 localhost）。file:// 下无法可靠使用麦克风
        function isSecureContext() {
            return typeof window.isSecureContext !== 'undefined' && window.isSecureContext
                && navigator.mediaDevices && typeof navigator.mediaDevices.enumerateDevices === 'function';
        }

        // 获取当前系统默认的麦克风 deviceId（需先有权限）
        async function getDefaultAudioInputId() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                const track = stream.getAudioTracks()[0];
                const id = track ? track.getSettings().deviceId : null;
                stream.getTracks().forEach(t => t.stop());
                return id || null;
            } catch (e) {
                return null;
            }
        }

        // 参考 Web-AI-Kit：设备变化防抖
        function handleDeviceChange() {
            clearTimeout(deviceChangeDebounceTimer);
            deviceChangeDebounceTimer = setTimeout(() => {
                populateDeviceList(micTabDeviceListLoaded);
            }, 500);
        }

        // 获取麦克风设备列表（参考 Web-AI-Kit：插拔后保持/恢复选中项，新设备可标出）
        async function populateDeviceList(requirePermission = false) {
            const selectElement = document.getElementById('mic-device');
            const hintEl = document.getElementById('mic-device-hint');

            if (!isSecureContext()) {
                selectElement.innerHTML = '<option value="">使用系统默认</option>';
                if (hintEl) hintEl.textContent = '请通过 localhost 或 HTTPS 打开本页面，否则无法使用麦克风';
                return;
            }

            try {
                const devices = await navigator.mediaDevices.enumerateDevices();
                const audioInputs = devices.filter(d => d.kind === 'audioinput');
                const currentAudioId = selectElement.value;
                const hadPreviousList = previousAudioDevices.length > 0;
                const newAudioDevice = audioInputs.find(d => !previousAudioDevices.some(p => p.deviceId === d.deviceId));
                previousAudioDevices = audioInputs;

                let defaultId = null;
                if (requirePermission && audioInputs.length) {
                    try {
                        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                        const track = stream.getAudioTracks()[0];
                        if (track) defaultId = track.getSettings().deviceId || null;
                        stream.getTracks().forEach(t => t.stop());
                    } catch (e) {}
                }

                selectElement.innerHTML = '<option value="">使用系统默认</option>';
                let hasCurrentAudio = false;
                const labelCount = {};
                audioInputs.forEach((device, index) => {
                    const option = document.createElement('option');
                    option.value = device.deviceId;
                    let label = device.label && device.label.trim() ? device.label : `${device.kind} ${(device.deviceId || '').slice(0, 8)}`;
                    if (label in labelCount) {
                        labelCount[label]++;
                        label = label + ' (#' + labelCount[label] + ')';
                    } else {
                        labelCount[label] = 1;
                    }
                    if (defaultId && device.deviceId === defaultId) label = '【系统默认】 ' + label;
                    option.textContent = label;
                    selectElement.appendChild(option);
                    if (device.deviceId === currentAudioId) hasCurrentAudio = true;
                });

                if (hadPreviousList && newAudioDevice) {
                    selectElement.value = newAudioDevice.deviceId;
                } else if (currentAudioId && !hasCurrentAudio && selectElement.options.length > 1) {
                    selectElement.selectedIndex = 0;
                } else if (currentAudioId && hasCurrentAudio) {
                    selectElement.value = currentAudioId;
                }

                if (hintEl) hintEl.textContent = audioInputs.length ? '' : '未检测到麦克风设备';
            } catch (err) {
                console.error('无法获取设备列表:', err);
                selectElement.innerHTML = '<option value="">使用系统默认</option>';
                if (hintEl) hintEl.textContent = '需要允许麦克风权限才能列出设备';
            }
        }

        // 是否已在麦克风标签内请求过权限并拉取过设备列表
        let micTabDeviceListLoaded = false;

        // 初始化
        async function init() {
            // 先不请求麦克风权限，仅在有 mediaDevices 时预填一次（可能无标签）
            if (isSecureContext()) {
                await populateDeviceList(false);
                navigator.mediaDevices.addEventListener('devicechange', handleDeviceChange);
            } else {
                populateDeviceList(false);
            }

            // 设置标签切换：切换到麦克风标签时再请求权限并刷新设备列表（才能显示设备名称）
            document.querySelectorAll('.tab-button').forEach(button => {
                button.addEventListener('click', async () => {
                    const tabId = button.getAttribute('data-tab');
                    document.querySelectorAll('.tab-button').forEach(btn => btn.classList.remove('active'));
                    button.classList.add('active');
                    document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
                    document.getElementById(`${tabId}-tab`).classList.add('active');

                    if (tabId === 'microphone' && isSecureContext() && !micTabDeviceListLoaded) {
                        micTabDeviceListLoaded = true;
                        await populateDeviceList(true);
                    }
                });
            });

            setupEventListeners();
        }

        function setupEventListeners() {
            // 上传标签
            document.getElementById('audio-upload').addEventListener('change', function(e) {
                const fileName = e.target.files[0]?.name || '';
                document.getElementById('file-name').textContent = fileName || '未选择文件';
            });
            
            document.getElementById('upload-btn').addEventListener('click', handleUpload);
            
            // 麦克风标签
            document.getElementById('start-rec-btn').addEventListener('click', startRecording);
            document.getElementById('stop-rec-btn').addEventListener('click', stopRecording);
            document.getElementById('play-btn').addEventListener('click', playRecording);
            document.getElementById('download-btn').addEventListener('click', downloadRecording);
            document.getElementById('test-device-btn').addEventListener('click', toggleTestDevice);
        }

        let testStream = null;
        let testAnimId = null;

        let levelPeak = 0;

        // 更新音量条和数字；peakPct 为本次录音/测试以来的峰值，便于对比不同设备
        function updateLevelDisplay(rawMax, peakPct) {
            const wrap = document.getElementById('visualizer-level-wrap');
            const numEl = document.getElementById('visualizer-level-num');
            const barEl = document.getElementById('visualizer-level-bar');
            const peakEl = document.getElementById('visualizer-level-peak');
            if (!wrap || !numEl || !barEl) return;
            wrap.style.display = 'flex';
            const pct = Math.min(100, Math.round((rawMax / 255) * 100));
            if (peakPct != null) levelPeak = Math.max(levelPeak, peakPct);
            numEl.textContent = pct + '%';
            barEl.style.width = pct + '%';
            if (peakEl) peakEl.textContent = '峰值 ' + levelPeak + '%';
        }
        function hideLevelDisplay() {
            const wrap = document.getElementById('visualizer-level-wrap');
            if (wrap) wrap.style.display = 'none';
            const bar = document.getElementById('visualizer-level-bar');
            if (bar) bar.style.width = '0%';
            levelPeak = 0;
        }
        function resetLevelPeak() {
            levelPeak = 0;
        }

        // 若正在测试设备，则停止测试（供开始录音时调用，避免测试与录音同时占用）
        function stopTestDeviceIfActive() {
            if (!testStream) return;
            const btn = document.getElementById('test-device-btn');
            const statusEl = document.getElementById('mic-test-status');
            const visualizer = document.getElementById('audio-visualizer');
            testStream.getTracks().forEach(t => t.stop());
            testStream = null;
            if (testAnimId) cancelAnimationFrame(testAnimId);
            testAnimId = null;
            if (visualizer) visualizer.innerHTML = '';
            if (statusEl) statusEl.textContent = '';
            if (btn) btn.textContent = '测试此设备';
            hideLevelDisplay();
        }

        async function toggleTestDevice() {
            const btn = document.getElementById('test-device-btn');
            const statusEl = document.getElementById('mic-test-status');
            const visualizer = document.getElementById('audio-visualizer');

            if (testStream) {
                stopTestDeviceIfActive();
                return;
            }

            btn.textContent = '停止测试';
            statusEl.textContent = '正在打开设备…';
            const deviceId = document.getElementById('mic-device').value;
            const constraints = { audio: deviceId ? { deviceId: { exact: deviceId } } : true };

            try {
                testStream = await navigator.mediaDevices.getUserMedia(constraints);
                resetLevelPeak();
                statusEl.textContent = '测试中：请大声说一句话，看「峰值」数字 — 换设备再测，峰值最高的就是最灵敏的';
                if (!audioContext) audioContext = new (window.AudioContext || window.webkitAudioContext)();
                if (audioContext.state === 'suspended') await audioContext.resume();
                const ctx = audioContext;
                const anal = ctx.createAnalyser();
                anal.fftSize = 256;
                anal.smoothingTimeConstant = 0.5;
                const src = ctx.createMediaStreamSource(testStream);
                src.connect(anal);
                const bufLen = anal.frequencyBinCount;
                const dataArr = new Uint8Array(bufLen);
                const maxH = visualizer.offsetHeight || 100;
                const w = visualizer.offsetWidth || 300;
                const barW = Math.max(2, (w / bufLen) - 1);

                function draw() {
                    if (!testStream || testStream.active === false) return;
                    testAnimId = requestAnimationFrame(draw);
                    anal.getByteFrequencyData(dataArr);
                    const maxVal = Math.max.apply(null, dataArr);
                    const pct = Math.min(100, Math.round((maxVal / 255) * 100));
                    updateLevelDisplay(maxVal, pct);
                    visualizer.innerHTML = '';
                    for (let i = 0; i < bufLen; i++) {
                        const bar = document.createElement('div');
                        bar.className = 'visualizer-bar';
                        const raw = dataArr[i];
                        const barHeight = Math.max(2, Math.min(maxH, (raw / 255) * maxH));
                        bar.style.width = barW + 'px';
                        bar.style.height = barHeight + 'px';
                        bar.style.left = (i * (barW + 1)) + 'px';
                        bar.style.background = 'var(--primary-500)';
                        visualizer.appendChild(bar);
                    }
                }
                draw();
            } catch (e) {
                statusEl.textContent = '无法打开设备: ' + e.message;
                btn.textContent = '测试此设备';
            }
        }

        // 处理上传
        async function handleUpload() {
            const fileInput = document.getElementById('audio-upload');
            const language = document.getElementById('upload-language').value;
            const statusEl = document.getElementById('upload-status');
            
            if (!fileInput.files[0]) {
                alert('请选择音频文件');
                return;
            }
            
            statusEl.textContent = '正在上传和转录...';
            
            const formData = new FormData();
            formData.append('audio', fileInput.files[0], fileInput.files[0].name);
            formData.append('language', language);
            
            try {
                const response = await fetch(API_BASE + '/transcribe', {
                    method: 'POST',
                    body: formData
                });
                const result = await response.json();

                if (result.success) {
                    document.getElementById('upload-result').value = result.text;
                    statusEl.textContent = `转录完成 (语言: ${result.language})`;
                } else {
                    throw new Error(result.error || '未知错误');
                }
            } catch (error) {
                console.error('转录失败:', error);
                let msg = error.message;
                if (msg === 'Failed to fetch') {
                    msg = '无法连接服务器。请确认：① WSL 里 API 已启动 ② Docker 端口映射正确（如 -p 8000:80）③ 本页 API 地址为 ' + API_BASE;
                }
                document.getElementById('upload-result').value = '转录失败: ' + msg;
                statusEl.textContent = '转录失败: ' + msg;
            }
        }

        // 开始录音
        async function startRecording() {
            try {
                // 若正在测试设备，先自动停止，避免测试的语音激励与录音同时存在
                stopTestDeviceIfActive();

                // 确保 audioContext 已创建，并在用户点击下恢复（浏览器策略：未 resume 时无声音、可视化无数据）
                if (!audioContext) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    console.log('[录音] 新建 AudioContext, state=', audioContext.state);
                }
                if (audioContext.state === 'suspended') {
                    await audioContext.resume();
                    console.log('[录音] AudioContext resume 后 state=', audioContext.state);
                }

                const deviceId = document.getElementById('mic-device').value;
                const constraints = {
                    audio: deviceId ? { deviceId: { exact: deviceId } } : true
                };
                let stream;
                try {
                    stream = await navigator.mediaDevices.getUserMedia(constraints);
                } catch (err) {
                    if ((err.name === 'NotReadableError' || err.name === 'TrackStartError' || err.name === 'OverconstrainedError') && deviceId) {
                        await new Promise(r => setTimeout(r, 200));
                        stream = await navigator.mediaDevices.getUserMedia(constraints);
                    } else {
                        throw err;
                    }
                }
                stream.getTracks().forEach(track => {
                    track.onended = () => {
                        if (navigator.mediaDevices) handleDeviceChange();
                    };
                });
                console.log('[录音] getUserMedia 成功, 音轨数=', stream.getAudioTracks().length, 'enabled=', stream.getAudioTracks().map(t => t.enabled));

                visualizerLogCount = 0;
                resetLevelPeak();
                setupAudioVisualizer(stream);

                // 同时用 PCM 录制一份 WAV，避免 weba 无声音/时长错
                pcmChunks = [];
                recordingStartTime = Date.now();
                const bufferSize = 4096;
                const scriptProcessor = audioContext.createScriptProcessor(bufferSize, 1, 1);
                const gainNode = audioContext.createGain();
                gainNode.gain.value = 0;
                const pcmSource = audioContext.createMediaStreamSource(stream);
                pcmSource.connect(scriptProcessor);
                scriptProcessor.connect(gainNode);
                gainNode.connect(audioContext.destination);
                scriptProcessor.onaudioprocess = (e) => {
                    const input = e.inputBuffer.getChannelData(0);
                    pcmChunks.push(new Float32Array(input));
                };

                // 优先使用浏览器支持的格式，避免录音为空
                const mimeOpts = ['audio/webm;codecs=opus', 'audio/webm', 'audio/ogg;codecs=opus', 'audio/mp4'];
                let mimeType = 'audio/webm';
                for (const m of mimeOpts) {
                    if (MediaRecorder.isTypeSupported(m)) {
                        mimeType = m;
                        break;
                    }
                }
                console.log('[录音] MediaRecorder 使用 mimeType=', mimeType);

                mediaRecorder = new MediaRecorder(stream, { mimeType: mimeType });
                audioChunks = [];

                mediaRecorder.ondataavailable = event => {
                    if (event.data && event.data.size > 0) {
                        audioChunks.push(event.data);
                        console.log('[录音] ondataavailable 块数=', audioChunks.length, '本块 size=', event.data.size);
                    }
                };

                mediaRecorder.onstop = async () => {
                    scriptProcessor.disconnect();
                    gainNode.disconnect();
                    pcmSource.disconnect();

                    const mime = mediaRecorder.mimeType || 'audio/webm';
                    recordedAudioBlob = new Blob(audioChunks, { type: mime });
                    console.log('[录音] onstop: 块数=', audioChunks.length, 'blob.size=', recordedAudioBlob.size, 'pcmChunks=', pcmChunks.length);

                    if (pcmChunks.length > 0) {
                        try {
                            const wavBlob = encodePCMToWav(pcmChunks, audioContext.sampleRate);
                            if (wavBlob && wavBlob.size > 0) {
                                recordedAudioBlob = wavBlob;
                                console.log('[录音] 已用 WAV 格式, size=', wavBlob.size);
                            }
                        } catch (e) {
                            console.warn('[录音] WAV 编码失败:', e);
                        }
                    }
                    pcmChunks = [];

                    stream.getTracks().forEach(track => track.stop());
                    if (animationId) {
                        cancelAnimationFrame(animationId);
                    }
                    document.getElementById('audio-visualizer').innerHTML = '';
                    hideLevelDisplay();
                    document.getElementById('start-rec-btn').disabled = false;
                    document.getElementById('stop-rec-btn').disabled = true;
                    document.getElementById('mic-device').disabled = false;
                    document.getElementById('test-device-btn').disabled = false;
                    document.getElementById('rec-status').innerHTML = '就绪';
                    document.getElementById('play-btn').disabled = false;
                    document.getElementById('download-btn').disabled = false;

                    if (recordedAudioBlob.size === 0) {
                        document.getElementById('mic-status').textContent = '录音为空，请录久一点再点停止';
                        return;
                    }
                    await transcribeRecordedAudio();
                };

                // 不传 timeslice，停止时只收到一块完整 WebM，避免多块拼接导致无声音/时长错
                mediaRecorder.start();

                document.getElementById('start-rec-btn').disabled = true;
                document.getElementById('stop-rec-btn').disabled = false;
                document.getElementById('mic-device').disabled = true;
                document.getElementById('test-device-btn').disabled = true;
                document.getElementById('rec-status').innerHTML = '<span class="recording-indicator"></span>正在录音...';
            } catch (err) {
                console.error('无法访问麦克风:', err);
                document.getElementById('mic-status').textContent = '无法访问麦克风: ' + err.message;
                
                // 更新UI状态
                document.getElementById('start-rec-btn').disabled = false;
                document.getElementById('stop-rec-btn').disabled = true;
                document.getElementById('rec-status').textContent = '无法访问麦克风: ' + err.message;
            }
        }

        // 设置音频可视化（依赖 AudioContext 已 resume，否则数据全为 0）
        let visualizerLogCount = 0;
        function setupAudioVisualizer(stream) {
            if (!audioContext) {
                console.error('[可视化] AudioContext 未初始化');
                return;
            }
            if (audioContext.state === 'suspended') {
                console.warn('[可视化] AudioContext 仍为 suspended，声波图可能无变化，需在用户点击下 resume');
            }

            if (analyser) {
                try { analyser.disconnect(); } catch (e) {}
            }
            analyser = audioContext.createAnalyser();
            analyser.fftSize = 256;
            analyser.smoothingTimeConstant = 0.6;
            const source = audioContext.createMediaStreamSource(stream);
            source.connect(analyser);
            const bufferLength = analyser.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);

            console.log('[可视化] 已连接 stream, fftSize=256, bufferLength=', bufferLength);

            function draw() {
                if (!analyser) return;
                animationId = requestAnimationFrame(draw);
                analyser.getByteFrequencyData(dataArray);
                const maxVal = Math.max.apply(null, dataArray);
                const pct = Math.min(100, Math.round((maxVal / 255) * 100));
                updateLevelDisplay(maxVal, pct);
                if (visualizerLogCount < 3 && maxVal > 0) {
                    console.log('[可视化] 有数据 max=', maxVal);
                    visualizerLogCount++;
                }

                const visualizer = document.getElementById('audio-visualizer');
                const w = visualizer.offsetWidth || 300;
                visualizer.innerHTML = '';
                const barWidth = Math.max(2, (w / bufferLength) - 1);
                const maxH = visualizer.offsetHeight || 100;
                for (let i = 0; i < bufferLength; i++) {
                    const bar = document.createElement('div');
                    bar.className = 'visualizer-bar';
                    const raw = dataArray[i];
                    const barHeight = Math.max(2, Math.min(maxH, (raw / 255) * maxH));
                    bar.style.width = barWidth + 'px';
                    bar.style.height = barHeight + 'px';
                    bar.style.left = (i * (barWidth + 1)) + 'px';
                    bar.style.background = 'var(--primary-500)';
                    visualizer.appendChild(bar);
                }
            }
            draw();
        }

        // 停止录音
        function stopRecording() {
            if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                mediaRecorder.stop();
                document.getElementById('stop-rec-btn').disabled = true;
                document.getElementById('start-rec-btn').disabled = false;
            }
        }

        // 播放录音（等音频可播后再 play，并保证音量开启）
        let _currentPlayUrl = null;
        function playRecording() {
            if (!recordedAudioBlob) {
                console.warn('[播放] 无录音 blob');
                return;
            }
            const audioPlayer = document.getElementById('audio-player');
            const playerContainer = document.getElementById('audio-player-container');
            if (_currentPlayUrl) URL.revokeObjectURL(_currentPlayUrl);
            _currentPlayUrl = URL.createObjectURL(recordedAudioBlob);
            audioPlayer.src = _currentPlayUrl;
            audioPlayer.volume = 1;
            audioPlayer.muted = false;
            playerContainer.style.display = 'block';
            audioPlayer.load();
            const playWhenReady = () => {
                audioPlayer.play().then(() => {
                    console.log('[播放] 已开始');
                }).catch(err => {
                    console.error('[播放] 失败:', err);
                });
            };
            if (audioPlayer.readyState >= 2) {
                playWhenReady();
            } else {
                audioPlayer.addEventListener('canplay', playWhenReady, { once: true });
            }
        }

        // 下载录音（固定文件名 recording.weba，避免浏览器生成 UUID.weba）
        function downloadRecording() {
            if (!recordedAudioBlob || recordedAudioBlob.size === 0) return;
            const mime = recordedAudioBlob.type || 'audio/webm';
            const ext = mime.indexOf('wav') !== -1 ? 'wav' : (mime.indexOf('webm') !== -1 ? 'weba' : (mime.indexOf('ogg') !== -1 ? 'ogg' : 'weba'));
            const a = document.createElement('a');
            a.href = URL.createObjectURL(recordedAudioBlob);
            a.download = 'recording.' + ext;
            a.click();
            URL.revokeObjectURL(a.href);
        }

        // 转录录音
        async function transcribeRecordedAudio() {
            const statusEl = document.getElementById('mic-status');
            if (!recordedAudioBlob || recordedAudioBlob.size === 0) {
                statusEl.textContent = '没有可上传的录音，请先录音再停止';
                return;
            }
            statusEl.textContent = '正在转录...';

            const mime = recordedAudioBlob.type || 'audio/webm';
            const ext = mime.indexOf('wav') !== -1 ? 'wav' : (mime.indexOf('webm') !== -1 ? 'webm' : (mime.indexOf('ogg') !== -1 ? 'ogg' : 'webm'));
            const formData = new FormData();
            formData.append('audio', recordedAudioBlob, 'recording.' + ext);
            formData.append('language', document.getElementById('mic-language').value);

            try {
                const response = await fetch(API_BASE + '/transcribe', {
                    method: 'POST',
                    body: formData
                });
                const result = await response.json();

                if (result.success) {
                    document.getElementById('mic-result').value = result.text;
                    statusEl.textContent = `转录完成 (语言: ${result.language})`;
                } else {
                    throw new Error(result.error || '未知错误');
                }
            } catch (error) {
                console.error('转录失败:', error);
                let msg = error.message;
                if (msg === 'Failed to fetch') {
                    msg = '无法连接服务器。请确认：① WSL 里 API 已启动 ② Docker 端口映射正确（如 -p 8000:80）③ 本页 API 地址为 ' + API_BASE;
                }
                document.getElementById('mic-result').value = '转录失败: ' + msg;
                statusEl.textContent = '转录失败: ' + msg;
            }
        }

        // 页面加载完成后初始化
        document.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>
